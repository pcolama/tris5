<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Tetris Clone</title>
<style>
  body {
    background: #111;
    color: #fff;
    font-family: Arial, sans-serif;
    text-align: center;
    margin: 0;
    padding: 0;
  }
  h1 {
    margin-top: 15px;
    font-size: 32px;
  }
  #score {
    font-size: 20px;
    margin-bottom: 10px;
  }
  canvas {
    background: #222;
    display: block;
    margin: 0 auto;
    border: 3px solid #555;
    cursor: none;
  }
  #info {
    font-size: 12px;
    color: #aaa;
    margin-top: 8px;
    line-height: 1.4em;
  }
  #game-over {
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0,0,0,0.85);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    color: white;
    font-size: 28px;
    visibility: hidden;
  }
  #restart {
    margin-top: 20px;
    padding: 10px 20px;
    font-size: 20px;
    background: #28a745;
    border: none;
    border-radius: 6px;
    color: white;
    cursor: pointer;
  }
  #restart:hover {
    background: #34d058;
  }
</style>
</head>
<body>
<h1>Tetris Clone</h1>
<div id="score">Punteggio: 0</div>
<canvas id="tetris" width="240" height="480"></canvas>

<div id="info">
  <p>
    <b>Comandi:</b> Frecce = muovi / ruota (↑), Spazio = caduta rapida, P = pausa.<br>
    Mouse = muovi a destra/sinistra, click sinistro = ruota, click destro = caduta rapida.
  </p>
</div>

<div id="game-over">
  <div>GAME OVER</div>
  <div id="final-score"></div>
  <button id="restart">Ricomincia</button>
</div>

<script>
const canvas = document.getElementById('tetris');
const ctx = canvas.getContext('2d');
const ROWS = 20;
const COLS = 10;
const BLOCK_SIZE = 24;

let board = Array.from({length: ROWS}, () => Array(COLS).fill(0));

const SHAPES = {
  I: [[1,1,1,1]],
  J: [[1,0,0],[1,1,1]],
  L: [[0,0,1],[1,1,1]],
  O: [[1,1],[1,1]],
  S: [[0,1,1],[1,1,0]],
  T: [[0,1,0],[1,1,1]],
  Z: [[1,1,0],[0,1,1]]
};

const COLORS = {
  I: '#00ffff',
  J: '#0000ff',
  L: '#ff7f00',
  O: '#ffff00',
  S: '#00ff00',
  T: '#800080',
  Z: '#ff0000'
};

const PIECE_TYPES = Object.keys(SHAPES);

let currentPiece, pos, color;
let dropInterval = 1000;
let lastTime = 0;
let score = 0;
let gameOver = false;
let paused = false;
let lastMouseX = null;

// Suoni (opzionali)
const soundRotate     = new Audio('rotate.mp3');
const soundLineClear  = new Audio('line-clear.mp3');
const soundGameOver   = new Audio('gameover.mp3');
soundRotate.volume    = 0.5;
soundLineClear.volume = 0.5;
soundGameOver.volume  = 0.7;

function newPiece() {
  const type = PIECE_TYPES[Math.floor(Math.random() * PIECE_TYPES.length)];
  currentPiece = SHAPES[type].map(r => [...r]);
  color = COLORS[type];
  pos = {x: Math.floor(COLS/2) - Math.ceil(currentPiece[0].length/2), y: 0};
  if (collide(board, currentPiece, pos)) endGame();
}

function collide(board, piece, pos) {
  for (let y=0; y<piece.length; y++) {
    for (let x=0; x<piece[y].length; x++) {
      if (piece[y][x]) {
        if (!board[y + pos.y] || board[y + pos.y][x + pos.x] !== 0) {
          return true;
        }
      }
    }
  }
  return false;
}

function merge(board, piece, pos) {
  piece.forEach((row, y) => {
    row.forEach((val, x) => {
      if (val) board[y + pos.y][x + pos.x] = color;
    });
  });
}

function rotate(matrix, dir = 1) {
  const N = matrix.length;
  const M = matrix[0].length;
  let result = Array.from({length: M}, () => Array(N).fill(0));
  for (let y = 0; y < N; y++) {
    for (let x = 0; x < M; x++) {
      if (dir > 0) result[x][N - 1 - y] = matrix[y][x];
      else result[M - 1 - x][y] = matrix[y][x];
    }
  }
  return result;
}

function drawBlock(x, y, color) {
  ctx.fillStyle = color;
  ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE-1, BLOCK_SIZE-1);
}

function draw() {
  ctx.clearRect(0,0,canvas.width,canvas.height);
  board.forEach((row, y) => row.forEach((val, x) => {
    if (val) drawBlock(x, y, val);
  }));
  currentPiece.forEach((row, y) => row.forEach((val, x) => {
    if (val) drawBlock(x + pos.x, y + pos.y, color);
  }));
}

function drop() {
  pos.y++;
  if (collide(board, currentPiece, pos)) {
    pos.y--;
    merge(board, currentPiece, pos);
    clearLines();
    newPiece();
  }
  lastTime = performance.now();
}

function clearLines() {
  let lines = 0;
  for (let y = ROWS - 1; y >= 0; y--) {
    if (board[y].every(cell => cell !== 0)) {
      board.splice(y, 1);
      board.unshift(Array(COLS).fill(0));
      lines++;
      y++;
    }
  }
  if (lines > 0) {
    score += lines * 100;
    document.getElementById('score').textContent = 'Punteggio: ' + score;
    if (dropInterval > 200) dropInterval -= 50;
    soundLineClear.play();
  }
}

function move(dir) {
  pos.x += dir;
  if (collide(board, currentPiece, pos)) pos.x -= dir;
}

function hardDrop() {
  while (!collide(board, currentPiece, pos)) pos.y++;
  pos.y--;
  merge(board, currentPiece, pos);
  clearLines();
  newPiece();
}

function update(time = 0) {
  if (gameOver || paused) return;
  const delta = time - lastTime;
  if (delta > dropInterval) drop();
  draw();
  requestAnimationFrame(update);
}

function endGame() {
  gameOver = true;
  document.getElementById('final-score').textContent = 'Punteggio finale: ' + score;
  document.getElementById('game-over').style.visibility = 'visible';
  soundGameOver.play();
}

function restartGame() {
  board = Array.from({length: ROWS}, () => Array(COLS).fill(0));
  score = 0;
  dropInterval = 1000;
  gameOver = false;
  paused = false;
  document.getElementById('score').textContent = 'Punteggio: 0';
  document.getElementById('game-over').style.visibility = 'hidden';
  newPiece();
  lastTime = performance.now();
  update();
}

function togglePause() {
  paused = !paused;
  if (!paused) {
    lastTime = performance.now();
    update();
  }
}

// --- Controlli tastiera ---
document.addEventListener('keydown', e => {
  if (gameOver) return;
  if (e.key === 'ArrowLeft') move(-1);
  else if (e.key === 'ArrowRight') move(1);
  else if (e.key === 'ArrowDown') drop();
  else if (e.key === ' ') hardDrop();
  else if (e.key === 'ArrowUp') {
    const rotated = rotate(currentPiece, 1);
    if (!collide(board, rotated, pos)) {
      currentPiece = rotated;
      soundRotate.play();
    }
  } else if (e.key.toLowerCase() === 'p') {
    togglePause();
  }
});

// --- Controlli mouse ---
canvas.addEventListener('contextmenu', e => e.preventDefault());

// Attiva il "pointer lock" quando clicchi sul canvas
canvas.addEventListener('click', () => {
  if (!document.pointerLockElement) {
    canvas.requestPointerLock();
  }
});

// Gestione uscita dal pointer lock
document.addEventListener('pointerlockchange', () => {
  if (document.pointerLockElement === canvas) {
    console.log('Pointer lock attivo');
  } else {
    console.log('Pointer lock disattivato');
    lastMouseX = null;
  }
});

// Quando il mouse si muove mentre il pointer lock è attivo
document.addEventListener('mousemove', e => {
  if (gameOver || paused) return;
  if (document.pointerLockElement === canvas) {
    const movement = e.movementX;
    // se il movimento è notevole, muovi il pezzo
    if (movement > 5) move(1);
    else if (movement < -5) move(-1);
  }
});

// Click sinistro = ruota, destro = caduta rapida
canvas.addEventListener('mousedown', e => {
  if (gameOver || paused) return;
  if (e.button === 0) {
    const rotated = rotate(currentPiece, 1);
    if (!collide(board, rotated, pos)) {
      currentPiece = rotated;
      soundRotate.play();
    }
  } else if (e.button === 2) {
    hardDrop();
  }
});

document.getElementById('restart').addEventListener('click', restartGame);

// Avvio
newPiece();
update();
</script>
</body>
</html>
